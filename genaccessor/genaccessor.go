/*
genaccessor is accsessor generator for Go.

```go
    type Foo struct {
        key string `getter:"[alias,]..." setter:"[alias,]..."`
    }
```

with `go generate` command

```go
    //go:generate go-genaccessor
```
*/
package genaccessor

import (
	"bytes"
	"go/ast"
	"go/format"
	"io"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/hori-ryota/go-genutil/genutil"
	"github.com/hori-ryota/go-strcase"
)

type Option func(o *option)

type option struct {
	fileFilter    func(finfo os.FileInfo) bool
	generatorName string
}

func WithFileFilter(fileFilter func(finfo os.FileInfo) bool) Option {
	return func(o *option) {
		o.fileFilter = fileFilter
	}
}

func WithGeneratorName(generatorName string) Option {
	return func(o *option) {
		o.generatorName = generatorName
	}
}

func Run(targetDir string, newWriter func(pkg *ast.Package) io.Writer, opts ...Option) error {
	option := option{
		generatorName: "go-genaccessor",
	}
	for _, opt := range opts {
		opt(&option)
	}

	walkers, err := genutil.DirToAstWalker(targetDir, option.fileFilter)
	if err != nil {
		return err
	}

	for _, walker := range walkers {
		body := new(bytes.Buffer)
		importPackages := make(map[string]string, 10)
		for _, spec := range walker.AllStructSpecs() {
			structType := spec.Type.(*ast.StructType)
			for _, field := range structType.Fields.List {
				if field.Tag == nil {
					continue
				}
				tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))

				typePrinter, err := walker.ToTypePrinter(field.Type)
				if err != nil {
					return err
				}

				for _, accessorTmpl := range accessorTmpls {
					methodNamesText, hasTag := tag.Lookup(accessorTmpl.tagKey)
					if !hasTag {
						continue
					}

					fieldName := genutil.ParseFieldName(field)
					methodNames := []string{accessorTmpl.defaultMethodName(fieldName)}
					if len(methodNamesText) != 0 {
						methodNames = strings.Split(methodNamesText, ",")
					}

					for n, pkg := range typePrinter.ImportPkgMap(walker.PkgPath) {
						importPackages[n] = pkg
					}

					for _, methodName := range methodNames {
						if err := accessorTmpl.tmpl.Execute(body, tmplParam{
							StructName: spec.Name.Name,
							MethodName: methodName,
							FieldType:  typePrinter.Print(walker.PkgPath),
							FieldName:  fieldName,
						}); err != nil {
							panic(err)
						}
					}
				}
			}
		}
		if body.Len() == 0 {
			continue
		}

		out := new(bytes.Buffer)

		err = template.Must(template.New("out").Parse(`
			// Code generated by {{ .GeneratorName }}; DO NOT EDIT.
		
			package {{ .PackageName }}
		
			{{ .ImportPackages }}
		
			{{ .Body }}
		`)).Execute(out, map[string]string{
			"GeneratorName":  option.generatorName,
			"PackageName":    walker.Pkg.Name,
			"ImportPackages": genutil.GoFmtImports(importPackages),
			"Body":           body.String(),
		})
		if err != nil {
			return err
		}

		str, err := format.Source(out.Bytes())
		if err != nil {
			return err
		}
		writer := newWriter(walker.Pkg)
		if closer, ok := writer.(io.Closer); ok {
			defer closer.Close()
		}
		if _, err := writer.Write(str); err != nil {
			return err
		}
	}

	return nil
}

type tmplParam struct {
	StructName string
	MethodName string
	FieldType  string
	FieldName  string
}

var accessorTmpls = []struct {
	tagKey            string
	tmpl              *template.Template
	defaultMethodName func(filedName string) string
}{
	{
		tagKey: "getter",
		tmpl: template.Must(template.New("getter").Parse(`
func (m {{ .StructName }}) {{ .MethodName }}() {{ .FieldType }} {
				return m.{{ .FieldName }}
			}
		`)),
		defaultMethodName: strcase.ToUpperCamel,
	},
	{
		tagKey: "setter",
		tmpl: template.Must(template.New("getter").Parse(`
func (m *{{ .StructName }}) {{ .MethodName }}(s {{ .FieldType }}) {
				m.{{ .FieldName }} = s
			}
		`)),
		defaultMethodName: func(fieldName string) string {
			return "Set" + strcase.ToUpperCamel(fieldName)
		},
	},
}
